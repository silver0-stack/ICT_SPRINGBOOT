 # Pageable과 Page의 정의
 ## Pageable
- 정의: `Pageable`은 **요청된 페이지 정보**를 캡슐화한 인터페이스이다. 주로 클라이언트로부터 전달 받은 페이징 파라미터
  (예: 페이지 번호, 페이지 크기, 정렬 기준)을 표현한다.
- 주요 메소드:
    - `pageGetNumber()`: 현재 페이지 번호(0부터 시작)
    - `getPageSize()`: 페이지당 항목 수
    - `getOffset()`: 데이터베이스 쿼리의 시작 위치(`offset`)
    - `getSort()`: 정렬 정보
- 구현 클래스: `PageRequest`
> `offset`이 뭐지?
> 
> **데이터 조회 시 건너뛸 항목의 수**
> 
> 예를 들어, `offset=20`이면 첫 번째부터 20번째까지의 데이터를 건너뛰고 **21번째 데이터부터** 조회를 시작함.
>`offset` 사용 시 데이터베이스는 필요한 부분만 조회할 수 있어 성능 최적화에 도움이 됨
> ### Pageable 인터페이스
> `Pageable`의 `getOffset()`: 데이터베이스 쿼리의 시작 위치(`offset`)
> 
> `offset = (currentPage - 1) * limit`, 만약 offset=10, 데이터베이스는 11번째 데이터부터 조회를 시작한다.

## Page
- 정의: `Page`는 **페이징된 결과**를 포함하는 인터페이스이다. 실제 데이터 리스트뿐만 아니라 페이징 메타데이터
  (총 페이지 수, 현재 페이지, 전체 데이터 수 등)을 포함한다.
- 주요 메소드:
    - `getContent()`: 실제 데이터 리스트
    - `getTotalElements()`: 전체 데이터 수
    - `getTotalPages()`: 전체 페이지 수
    - `getNumber()`: 현재 페이지 번호
    - `getSize()`: 페이지당 항목 수
    - `hasNext()`, `hasPrevious()`: 다음/이전 페이지 존재 여부
- 구현 클래스: `PageImpl`
---
# Pageable과 Page의 차이점
| ******특징******     | **Pageable**                                          | **Page**                                              |
|--------------|--------------------------------------------------------|-------------------------------------------------------|
| **역할**     | 페이징 요청 정보(페이지 번호, 크기, 정렬 등)를 캡슐화    | 페이징된 결과 데이터와 메타데이터를 캡슐화             |
| **위치**     | 주로 서비스 또는 컨트롤러 계층에서 요청 받을 때 사용     | 주로 리포지토리에서 반환하거나 컨트롤러에서 응답할 때 사용  |
| **종류**     | `PageRequest`와 같은 구현 클래스                       | `PageImpl`과 같은 구현 클래스                          |
| **상호 관계**| `Pageable`을 사용하여 리포지토리에서 `Page`를 생성      | `Page`는 `Pageable`을 기반으로 생성됨                   |
---
# Pageable과 Page의 상호 관계
### 1. 클라이언트 요청
- 클라이언트는 서버에 데이터 요청 시 페이징 관련 파라미터를 전달한다. 예를 들어, 특정 페이지 번호, 페이지 크기, 정렬 기준 등
### 2. 컨트롤러에서 Pageable 생성
- SpringMVC는 이러한 파라미터를 자동으로 `Pageable` 객체로 변환한다. 이는 `@RequestParam`을 통해 직접 받을 수도 있고, Spring Data가 자동으로 매핑해준다.
### 3. 서비스 및 리포지토리 계층으로 전달
- `Pageable` 객체는 서비스 계층을 통해 리포지토리 계층으로 전달된다.
- 리포지토리 계층에서는 `Pageable`을 사용하여 데이터베이스 쿼리를 생성하고, `Page` 객체를 반환한다.
### 4. Page 객체를 클라이언트에 반환
- `Page` 객체는 실제 데이터와 페이징 메타데이터를 포함하고 있으므로, 이를 클라이언트에 반환하여 클라이언트는 페이지 네비게이션 등을 구현할 수 있다.
---
# Pageable과 Page는 왜 사용되는지
### 대량 데이터 처리 효율성
대규모 데이터베이스에서 모든 데이터를 한 번에 조회하는 것은 메모리 사용량 증가, 네트워크 대역폭 낭비의 문제 야기한다.
`Pageable`과 `Page`를 사용하면 필요한 데이터만 효율적으로 조회하고 전달한다.
### 클라이언트 경험 향상
클라이언트는 페이징된 데이터를 받아서 페이지 네비게이션, 무한 스크롤 등 사용자 친화적인 UI를 구현할 수 있다.
### 서버 부하 분산
데이터를 페이징 처리하며 서버느 한 번에 처리해야 하는 데이터 양이 줄어들어, 서버 부하를 분산시킨다.

---
# 내 코드에서 Pageable과 Page의 활용 이유
### `memberListMethod`와 `memberSearchMethod`에서의 사용
- 목적: 회원 목록 조회 및 조건별 회원 검색 기능에서 페이징과 정렬을 지원하기 위해 사용
- 이점:
    - 효율적인 데이터 처리: 한 번에 많은 데이터 조회할 필요없이 예를 들어 10개의 데이터만 조회하여 처리
    - 유연한 정렬 및 페이징: 클라이언트가 요청하는 페이지 번호, 페이지 크기, 정렬 기준에 따라 유연하게 데이터 제공
    - 종합적인 응답: `Page` 객체를 통해 데이터 리스트뿐만 아니라, 전체 페이지 수, 현재 페이지, 전체 데이터 수 등의 메타데이터를 함께 제공하여 클라이언트가 페
  이지 네비게이션 등을 쉽게 구현할 수 있도록 지원
### 리포지토리 계층에서의 사용
- 기능:
  - `findAll(Pageable pageable)`: 모든 회원을 페이징하여 조회
  - `searchMembers(...)`: 조건에 맞는 회원을 페이징하여 조회
- 이점: 
  - 코드 간결성: Spring Data JPA가 제공하는 `Pageable`과 `Page`를 활용하여 복잡한 페이징 로직을 간결하게 구현
  - 확장성: 다양한 검색 조건과 페이징 요구사항에 유연하게 대응 가능
### 서비스 계층에서의 변환
- 기능:
  - `Page<MemberEntity>`를 `Page<Member>`로 변환하여 클라이언트에 적합한 형태로 제공
- 이점:
  - DTO 변환: 엔터티를 DTO로 변환하여 데이터 노출을 제어하고 필요한 정보만 클라이언트에 전달
  - 유지보수 용이성: 페이징된 데이터를 쉽게 관리하고 필요에 따라 추가적인 로직을 활용할 수 있음
---
## 추가적인 고려사항
### 페이지 번호의 0 기반 vs 1 기반
- 문제: Spring Data JPA의 `PageRequest`는 페이지 번호가 0부터 시작이지만, 클라이언트는 일반적으로 1부터 페이지 번호를 시작한다
- 해결책: `PageRequest.of(currentPage-1, limit, Sort.by(direction, sortBy))`를 사용하여 클라이언트 1기반의 페이지 번호를 0 기반으로 전환
### 정렬 기준의 유연성
- 문제: 클라이언트가 다양한 정렬 기준을 요청한다면?
- 해결책: `sort` 파라미터를 받아서 동적으로 `Sort`객체를 생성. 예를 들어, `sort=field,asc` 또는 `sort=field,desc` 형태로 정렬 기준으로 받아 처리
